from typing import List, Dict
from ..mappers.semantic_mapper import MappedTable, MappedColumn

class SqlGenerator:
    """
    Generates standardized SQL DDL from Semantic Mappings.
    """
    
    def generate_ddl(self, tables: List[MappedTable]) -> str:
        """
        Main entry point. Returns a single string containing all DDL statements.
        """
        ddl_statements = []
        ddl_statements.append("-- Generated by OntologyMirror")
        ddl_statements.append("-- Standard: Schema.org")
        ddl_statements.append("")
        
        for table in tables:
            ddl_statements.append(self._create_table_statement(table))
            
        return "\n".join(ddl_statements)

    def _create_table_statement(self, table: MappedTable) -> str:
        """
        Constructs CREATE TABLE for a single mapped entity.
        Example:
        -- Original: auth_user
        CREATE TABLE Person ( ... );
        """
        lines = []
        lines.append(f"-- Source: {table.original_table}")
        if table.rationale:
            lines.append(f"-- Rationale: {table.rationale}")
            
        # Use a safe name, replace spaces with underscores just in case
        safe_table_name = table.schema_class.replace(" ", "_")
        lines.append(f"CREATE TABLE {safe_table_name} (")
        
        col_defs = []
        for col in table.columns:
            def_str = self._create_column_definition(col)
            if def_str:
                col_defs.append(f"    {def_str}")
        
        # Join columns with commas
        lines.append(",\n".join(col_defs))
        lines.append(");\n")
        
        return "\n".join(lines)

    def _create_column_definition(self, col: MappedColumn) -> str:
        """
        Generates 'column_name TYPE' string.
        Attempts to map Schema.org properties to SQL types, or fallback.
        """
        # If schema_property is empty (no mapping), we skip it or comment it out?
        # Decision: If explicitly mapped, we generate.
        if not col.schema_property:
            return f"-- Unmapped column: {col.original_name}"
            
        safe_col_name = col.schema_property
        
        # Simple Type Inference based on property name or heuristics
        # Ideally this should come from the Mapper's 'normalized_type'
        # But for now we infer or use a default.
        sql_type = "TEXT" # Default
        
        if "date" in safe_col_name.lower():
            sql_type = "DATETIME"
        elif "id" in safe_col_name.lower() or "identifier" in safe_col_name.lower():
            # Keep original ID type loosely? Or standard INT/VARCHAR
            sql_type = "VARCHAR(255)" 
        elif "active" in safe_col_name.lower() or "boolean" in safe_col_name.lower():
            sql_type = "BOOLEAN"
            
        return f"{safe_col_name.ljust(20)} {sql_type}, -- from {col.original_name}"
